<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StasyaChess Pro - Игра с Stockfish</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f0f0f0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background-color: rgba(25, 25, 35, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            overflow: hidden;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }

        header {
            background: linear-gradient(90deg, #0f3460 0%, #1a1a2e 100%);
            padding: 25px 40px;
            border-bottom: 3px solid #e94560;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .logo i {
            font-size: 2.8rem;
            color: #e94560;
        }

        .logo h1 {
            font-size: 2.5rem;
            background: linear-gradient(90deg, #e94560, #ff7e5f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-container {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 30px;
            padding: 30px;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
            }
        }

        .board-section {
            background: rgba(40, 40, 60, 0.7);
            border-radius: 12px;
            padding: 20px;
        }

        .board-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .board-header h3 {
            color: #e94560;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #board-container {
            width: 460px;
            height: 460px;
            margin: 0 auto;
            border: 4px solid #394867;
            border-radius: 5px;
            background: #f0d9b5;
            position: relative;
        }

        .chess-board {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .control-panel {
            background: rgba(40, 40, 60, 0.7);
            border-radius: 12px;
            padding: 25px;
        }

        .panel-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-section h3 {
            color: #4cc9f0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-color-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 25px;
        }

        .color-btn {
            padding: 15px;
            border: none;
            border-radius: 8px;
            background: rgba(57, 72, 103, 0.8);
            color: white;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .color-btn:hover {
            transform: translateY(-3px);
        }

        .color-btn.active {
            background: linear-gradient(90deg, #e94560, #ff7e5f);
        }

        .difficulty-selector {
            margin-top: 25px;
        }

        .difficulty-slider {
            width: 100%;
            height: 40px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #4CAF50, #FF9800, #F44336);
            border-radius: 20px;
            margin: 20px 0;
        }

        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: white;
            border: 3px solid #394867;
            cursor: pointer;
        }

        .game-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            padding: 16px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(90deg, #e94560, #ff7e5f);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(233, 69, 96, 0.3);
        }

        .btn-secondary {
            background: rgba(57, 72, 103, 0.8);
            color: white;
            border: 1px solid #4a5f8a;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
            padding: 20px;
            background: rgba(30, 30, 46, 0.9);
            border-radius: 8px;
        }

        .info-item {
            text-align: center;
            padding: 15px;
            background: rgba(40, 40, 60, 0.7);
            border-radius: 8px;
        }

        .info-label {
            font-size: 0.9rem;
            color: #a9b7c6;
            margin-bottom: 8px;
        }

        .info-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #4cc9f0;
        }

        .board-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.8rem;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .light-square {
            background-color: #f0d9b5;
        }

        .dark-square {
            background-color: #b58863;
        }

        .board-square.selected {
            background-color: rgba(76, 201, 240, 0.7) !important;
        }

        .board-square.legal-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
        }

        .board-square.legal-capture::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            border: 4px solid rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            box-sizing: border-box;
        }

        .black-piece {
            color: #000;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .white-piece {
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .notation {
            position: absolute;
            font-size: 0.8rem;
            font-weight: bold;
            pointer-events: none;
        }

        .notation-file {
            bottom: 2px;
            right: 2px;
            color: rgba(0, 0, 0, 0.7);
        }

        .notation-rank {
            top: 2px;
            left: 2px;
            color: rgba(0, 0, 0, 0.7);
        }

        .hidden {
            display: none;
        }

        .engine-thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            z-index: 1000;
            border: 2px solid #e94560;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
            text-align: center;
            min-width: 200px;
        }

        .positive-eval {
            color: #4CAF50 !important;
        }

        .negative-eval {
            color: #F44336 !important;
        }

        .zero-eval {
            color: #FF9800 !important;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding: 10px 15px;
            background: rgba(30, 30, 46, 0.8);
            border-radius: 8px;
            border-left: 4px solid #4cc9f0;
        }

        .engine-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-ready {
            background-color: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .status-thinking {
            background-color: #FF9800;
            box-shadow: 0 0 10px #FF9800;
            animation: pulse 1.5s infinite;
        }

        .status-error {
            background-color: #F44336;
            box-shadow: 0 0 10px #F44336;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-success {
            background: linear-gradient(90deg, #2E7D32, #4CAF50);
            border-left: 4px solid #81C784;
        }

        .notification-warning {
            background: linear-gradient(90deg, #F57C00, #FF9800);
            border-left: 4px solid #FFB74D;
        }

        .notification-error {
            background: linear-gradient(90deg, #C62828, #F44336);
            border-left: 4px solid #EF9A9A;
        }

        .notification-info {
            background: linear-gradient(90deg, #1565C0, #2196F3);
            border-left: 4px solid #90CAF9;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-chess-knight"></i>
                <h1>StasyaChess Pro</h1>
            </div>
        </header>

        <div class="game-container">
            <div class="board-section">
                <div class="board-header">
                    <h3><i class="fas fa-chess-board"></i> Шахматная доска</h3>
                    <div id="game-status">Готов к игре</div>
                </div>
                
                <div id="board-container">
                    <div class="chess-board" id="chess-board"></div>
                    <div id="thinking-indicator" class="hidden engine-thinking">
                        <div style="text-align: center;">
                            <i class="fas fa-cogs fa-spin fa-2x" style="color: #4cc9f0; margin-bottom: 10px;"></i>
                            <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 5px;">Stockfish анализирует</div>
                            <div style="font-size: 0.9rem; color: #a9b7c6;">Пожалуйста, подождите...</div>
                        </div>
                    </div>
                </div>
                
                <!-- Строка статуса Stockfish -->
                <div class="status-bar">
                    <div class="engine-status">
                        <span class="status-indicator" id="engine-status-light"></span>
                        <span id="engine-status-text">Загрузка Stockfish...</span>
                    </div>
                    <div style="color: #a9b7c6; font-size: 0.9rem;">
                        Уровень: <span id="engine-level-display">10</span>
                    </div>
                </div>
                
                <div class="game-info">
                    <div class="info-item">
                        <div class="info-label">ХОД</div>
                        <div class="info-value" id="current-turn">белых</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">УРОВЕНЬ</div>
                        <div class="info-value" id="current-level">10</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ОЦЕНКА</div>
                        <div class="info-value" id="position-eval">0.00</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">ХОДОВ</div>
                        <div class="info-value" id="move-count">0</div>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <div class="panel-section">
                    <h3><i class="fas fa-user-cog"></i> Настройки игрока</h3>
                    
                    <div style="margin-bottom: 20px;">
                        <div style="margin-bottom: 12px;">Ваш цвет:</div>
                        <div class="player-color-selector">
                            <button class="color-btn active" id="color-white" data-color="white">
                                <i class="fas fa-chess-king white-piece"></i>
                                <span>Белые</span>
                            </button>
                            <button class="color-btn" id="color-black" data-color="black">
                                <i class="fas fa-chess-king black-piece"></i>
                                <span>Черные</span>
                            </button>
                            <button class="color-btn" id="color-random" data-color="random">
                                <i class="fas fa-random"></i>
                                <span>Случайно</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="difficulty-selector">
                        <div style="margin-bottom: 12px;">Уровень сложности:</div>
                        <input type="range" min="1" max="20" value="10" class="difficulty-slider" id="difficulty-slider">
                        <div style="text-align: center; margin-top: 10px; color: #4cc9f0;" id="difficulty-text">
                            Уровень 10 (ELO ~2000)
                        </div>
                    </div>
                    
                    <div class="game-controls">
                        <button id="new-game-btn" class="btn btn-primary">
                            <i class="fas fa-plus-circle"></i> Новая игра
                        </button>
                        <button id="undo-btn" class="btn btn-secondary" disabled>
                            <i class="fas fa-undo"></i> Отменить ход
                        </button>
                        <button id="hint-btn" class="btn btn-secondary">
                            <i class="fas fa-lightbulb"></i> Подсказка
                        </button>
                        <button id="analyze-btn" class="btn btn-secondary">
                            <i class="fas fa-chart-bar"></i> Анализ
                        </button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3><i class="fas fa-chart-line"></i> Статистика</h3>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 2rem; font-weight: bold; color: #4cc9f0;" id="player-elo">-</div>
                        <div style="margin-top: 10px; color: #a9b7c6;">Ваш примерный ELO</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Контейнер для уведомлений -->
    <div id="notification-container"></div>

    <!-- Подключаем Stockfish.js через CDN -->
    <script src="https://cdn.jsdelivr.net/npm/stockfish/src/stockfish.js"></script>
    
    <script>
        // ==================== КОНСТАНТЫ ====================
        const PIECE_SYMBOLS = {
            'p': '♟', 'n': '♞', 'b': '♝', 'r': '♜', 'q': '♛', 'k': '♚',
            'P': '♙', 'N': '♘', 'B': '♗', 'R': '♖', 'Q': '♕', 'K': '♔'
        };

        const INITIAL_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

        const DIRECTIONS = {
            pawn: { white: -1, black: 1 },
            knight: [
                [2, 1], [2, -1], [-2, 1], [-2, -1],
                [1, 2], [1, -2], [-1, 2], [-1, -2]
            ],
            bishop: [
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ],
            rook: [
                [1, 0], [-1, 0], [0, 1], [0, -1]
            ],
            queen: [
                [1, 1], [1, -1], [-1, 1], [-1, -1],
                [1, 0], [-1, 0], [0, 1], [0, -1]
            ],
            king: [
                [1, 1], [1, 0], [1, -1],
                [0, 1], [0, -1],
                [-1, 1], [-1, 0], [-1, -1]
            ]
        };

        // ==================== СОСТОЯНИЕ ИГРЫ ====================
        let gameState = {
            board: [],
            playerColor: 'white',
            currentTurn: 'white',
            selectedSquare: null,
            legalMoves: [],
            moves: [],
            engineLevel: 10,
            isGameActive: false,
            positionFEN: INITIAL_FEN,
            positionEvaluation: 0.00,
            isAnalyzing: false,
            stockfish: null,
            stockfishReady: false,
            moveHistory: [],
            materialBalance: 0
        };

        // ==================== ИНИЦИАЛИЗАЦИЯ ====================
        document.addEventListener('DOMContentLoaded', async function() {
            initBoard();
            setupEventListeners();
            updateEngineStatus('loading');
            await initStockfish();
            startNewGame();
        });

        // ==================== STOCKFISH ИНИЦИАЛИЗАЦИЯ ====================
        async function initStockfish() {
            try {
                // Используем Stockfish через Web Worker
                if (typeof Worker !== 'undefined') {
                    gameState.stockfish = new Worker('https://cdn.jsdelivr.net/npm/stockfish/src/stockfish.js');
                    
                    gameState.stockfish.onmessage = function(event) {
                        handleStockfishMessage(event.data);
                    };
                    
                    // Настраиваем Stockfish
                    sendToStockfish('uci');
                    sendToStockfish('isready');
                    
                } else {
                    throw new Error('Web Workers не поддерживаются');
                }
            } catch (error) {
                console.error('Ошибка инициализации Stockfish:', error);
                showNotification('Stockfish не загрузился. Используется случайный движок.', 'error');
                updateEngineStatus('error');
            }
        }

        function sendToStockfish(command) {
            if (gameState.stockfish) {
                gameState.stockfish.postMessage(command);
            }
        }

        function handleStockfishMessage(message) {
            console.log('Stockfish:', message);
            
            if (message === 'readyok') {
                gameState.stockfishReady = true;
                sendToStockfish('setoption name Skill Level value ' + gameState.engineLevel);
                updateEngineStatus('ready');
                showNotification('Stockfish готов к игре!', 'success');
                console.log('Stockfish готов к работе');
            }
            
            if (message.startsWith('bestmove')) {
                const parts = message.split(' ');
                if (parts.length >= 2) {
                    const bestMove = parts[1];
                    if (bestMove !== '(none)') {
                        updateEngineStatus('ready');
                        processEngineMove(bestMove);
                    }
                }
            }
            
            // Обработка оценки позиции
            if (message.startsWith('info') && (message.includes('score cp') || message.includes('score mate'))) {
                let evalScore = 0;
                
                if (message.includes('score mate')) {
                    const mateMatch = message.match(/score mate (-?\d+)/);
                    if (mateMatch) {
                        const mateIn = parseInt(mateMatch[1]);
                        evalScore = mateIn > 0 ? 1000 : -1000;
                    }
                } else if (message.includes('score cp')) {
                    const cpMatch = message.match(/score cp (-?\d+)/);
                    if (cpMatch) {
                        evalScore = parseInt(cpMatch[1]) / 100;
                    }
                }
                
                // Корректируем оценку для игрока
                gameState.positionEvaluation = evalScore;
                updateEvaluationDisplay();
            }
        }

        function updateEngineStatus(status) {
            const statusLight = document.getElementById('engine-status-light');
            const statusText = document.getElementById('engine-status-text');
            
            statusLight.classList.remove('status-ready', 'status-thinking', 'status-error');
            
            switch(status) {
                case 'loading':
                    statusLight.classList.add('status-thinking');
                    statusText.textContent = 'Загрузка Stockfish...';
                    break;
                case 'ready':
                    statusLight.classList.add('status-ready');
                    statusText.textContent = 'Stockfish готов';
                    break;
                case 'thinking':
                    statusLight.classList.add('status-thinking');
                    statusText.textContent = 'Stockfish думает...';
                    break;
                case 'error':
                    statusLight.classList.add('status-error');
                    statusText.textContent = 'Stockfish не доступен';
                    break;
            }
        }

        // ==================== ШАХМАТНАЯ ДОСКА ====================
        function initBoard() {
            const board = document.getElementById('chess-board');
            board.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `board-square ${(row + col) % 2 === 0 ? 'light-square' : 'dark-square'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Добавляем обозначения полей
                    if (row === 7) {
                        const file = document.createElement('div');
                        file.className = 'notation notation-file';
                        file.textContent = String.fromCharCode(97 + col);
                        square.appendChild(file);
                    }
                    if (col === 0) {
                        const rank = document.createElement('div');
                        rank.className = 'notation notation-rank';
                        rank.textContent = (8 - row).toString();
                        square.appendChild(rank);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    board.appendChild(square);
                }
            }
        }

        function updateBoard() {
            // Очищаем доску
            document.querySelectorAll('.board-square').forEach(square => {
                square.innerHTML = '';
                square.classList.remove('selected', 'legal-move', 'legal-capture');
                
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                
                // Восстанавливаем обозначения
                if (row === 7) {
                    const file = document.createElement('div');
                    file.className = 'notation notation-file';
                    file.textContent = String.fromCharCode(97 + col);
                    square.appendChild(file);
                }
                if (col === 0) {
                    const rank = document.createElement('div');
                    rank.className = 'notation notation-rank';
                    rank.textContent = (8 - row).toString();
                    square.appendChild(rank);
                }
            });
            
            // Расставляем фигуры
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        let displayRow = row;
                        let displayCol = col;
                        
                        // Если игрок черными, переворачиваем доску
                        if (gameState.playerColor === 'black') {
                            displayRow = 7 - row;
                            displayCol = 7 - col;
                        }
                        
                        const square = document.querySelector(`.board-square[data-row="${displayRow}"][data-col="${displayCol}"]`);
                        if (square) {
                            const pieceElement = document.createElement('div');
                            pieceElement.textContent = PIECE_SYMBOLS[piece];
                            pieceElement.style.cursor = 'pointer';
                            pieceElement.style.fontSize = '2.8rem';
                            pieceElement.style.lineHeight = '1';
                            
                            if (piece === piece.toLowerCase()) {
                                pieceElement.classList.add('black-piece');
                            } else {
                                pieceElement.classList.add('white-piece');
                            }
                            
                            square.appendChild(pieceElement);
                        }
                    }
                }
            }
        }

        function loadFEN(fen) {
            const parts = fen.split(' ');
            const boardStr = parts[0];
            const rows = boardStr.split('/');
            
            gameState.board = Array(8).fill().map(() => Array(8).fill(null));
            
            for (let i = 0; i < 8; i++) {
                let col = 0;
                for (let char of rows[i]) {
                    if (isNaN(char)) {
                        gameState.board[i][col] = char;
                        col++;
                    } else {
                        col += parseInt(char);
                    }
                }
            }
            
            gameState.currentTurn = parts[1] === 'w' ? 'white' : 'black';
            gameState.positionFEN = fen;
            calculateMaterialBalance();
            updateBoard();
            updateDisplay();
        }

        function getCurrentFEN() {
            let fen = '';
            
            // Позиция фигур
            for (let row = 0; row < 8; row++) {
                let empty = 0;
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        if (empty > 0) {
                            fen += empty;
                            empty = 0;
                        }
                        fen += piece;
                    } else {
                        empty++;
                    }
                }
                if (empty > 0) {
                    fen += empty;
                }
                if (row < 7) {
                    fen += '/';
                }
            }
            
            // Очередь хода
            fen += ' ' + (gameState.currentTurn === 'white' ? 'w' : 'b');
            
            // Рокировки (упрощенно)
            fen += ' KQkq';
            
            // Взятие на проходе
            fen += ' -';
            
            // Правило 50 ходов
            fen += ' 0';
            
            // Номер хода
            fen += ' ' + Math.floor(gameState.moves.length / 2 + 1);
            
            return fen;
        }

        // ==================== ИГРОВАЯ ЛОГИКА ====================
        function startNewGame() {
            gameState.selectedSquare = null;
            gameState.legalMoves = [];
            gameState.moves = [];
            gameState.moveHistory = [];
            gameState.isGameActive = true;
            gameState.isAnalyzing = false;
            gameState.positionEvaluation = 0.00;
            
            loadFEN(INITIAL_FEN);
            
            // Если игрок черными, Stockfish ходит первым
            if (gameState.playerColor === 'black') {
                setTimeout(() => getEngineMove(), 500);
            }
            
            updateDisplay();
            showNotification('Новая игра началась!', 'success');
        }

        function handleSquareClick(row, col) {
            if (!gameState.isGameActive || gameState.isAnalyzing) return;
            
            let actualRow = row, actualCol = col;
            if (gameState.playerColor === 'black') {
                actualRow = 7 - row;
                actualCol = 7 - col;
            }
            
            const piece = gameState.board[actualRow]?.[actualCol];
            const isPlayerTurn = gameState.currentTurn === gameState.playerColor;
            
            if (!isPlayerTurn) {
                showNotification('Сейчас ходит противник!', 'warning');
                return;
            }
            
            if (piece) {
                const isPlayerPiece = (gameState.playerColor === 'white' && piece === piece.toUpperCase()) ||
                                     (gameState.playerColor === 'black' && piece === piece.toLowerCase());
                
                if (isPlayerPiece) {
                    clearSelection();
                    
                    let displayRow = actualRow, displayCol = actualCol;
                    if (gameState.playerColor === 'black') {
                        displayRow = 7 - actualRow;
                        displayCol = 7 - actualCol;
                    }
                    
                    const square = document.querySelector(`.board-square[data-row="${displayRow}"][data-col="${displayCol}"]`);
                    square.classList.add('selected');
                    
                    gameState.selectedSquare = { row: actualRow, col: actualCol };
                    calculateLegalMoves(actualRow, actualCol, piece);
                    showLegalMoves();
                }
            } else if (gameState.selectedSquare) {
                const from = gameState.selectedSquare;
                const to = { row: actualRow, col: actualCol };
                
                if (isLegalMove(from, to)) {
                    makeMove(from, to);
                } else {
                    showNotification('Недопустимый ход!', 'error');
                }
                clearSelection();
            }
        }

        function makeMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            const capturedPiece = gameState.board[to.row][to.col];
            
            // Сохраняем состояние для отмены
            gameState.moveHistory.push({
                board: JSON.parse(JSON.stringify(gameState.board)),
                fen: gameState.positionFEN,
                moveCount: gameState.moves.length,
                capturedPiece: capturedPiece,
                from: from,
                to: to
            });
            
            // Проверяем превращение пешки
            const isPawn = piece.toLowerCase() === 'p';
            const isWhite = piece === piece.toUpperCase();
            const lastRow = isWhite ? 0 : 7;
            
            let promotion = '';
            if (isPawn && to.row === lastRow) {
                promotion = 'q'; // Автоматическое превращение в ферзя
            }
            
            // Выполняем ход (ВЗЯТИЕ ФИГУРЫ!)
            gameState.board[to.row][to.col] = promotion ? 
                (isWhite ? promotion.toUpperCase() : promotion) : piece;
            gameState.board[from.row][from.col] = null;
            
            // Если взяли фигуру, показываем уведомление
            if (capturedPiece) {
                const pieceNames = {
                    'p': 'пешку', 'n': 'коня', 'b': 'слона', 'r': 'ладью', 'q': 'ферзя', 'k': 'короля',
                    'P': 'пешку', 'N': 'коня', 'B': 'слона', 'R': 'ладью', 'Q': 'ферзя', 'K': 'короля'
                };
                const pieceName = pieceNames[capturedPiece] || 'фигуру';
                showNotification(`Вы взяли ${pieceName}!`, 'success');
            }
            
            // Меняем очередь хода
            gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
            
            // Сохраняем ход
            const fromNotation = `${String.fromCharCode(97 + from.col)}${8 - from.row}`;
            const toNotation = `${String.fromCharCode(97 + to.col)}${8 - to.row}`;
            const moveNotation = fromNotation + toNotation + (promotion || '');
            gameState.moves.push(moveNotation);
            
            // Обновляем FEN
            gameState.positionFEN = getCurrentFEN();
            calculateMaterialBalance();
            
            updateBoard();
            updateDisplay();
            
            // Включаем кнопку отмены
            document.getElementById('undo-btn').disabled = false;
            
            // Проверяем состояние игры
            checkGameState();
            
            // Если игра продолжается, ходит движок
            if (gameState.isGameActive && gameState.currentTurn !== gameState.playerColor) {
                setTimeout(() => getEngineMove(), 500);
            }
        }

        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastState = gameState.moveHistory.pop();
            gameState.board = lastState.board;
            gameState.positionFEN = lastState.fen;
            gameState.moves = gameState.moves.slice(0, -1);
            gameState.currentTurn = gameState.currentTurn === 'white' ? 'black' : 'white';
            calculateMaterialBalance();
            
            updateBoard();
            updateDisplay();
            
            // Если история пуста, отключаем кнопку отмены
            if (gameState.moveHistory.length === 0) {
                document.getElementById('undo-btn').disabled = true;
            }
            
            showNotification('Ход отменен', 'info');
        }

        // ==================== РАСЧЕТ ХОДОВ (ИСПРАВЛЕННЫЙ) ====================
        function calculateLegalMoves(row, col, piece) {
            gameState.legalMoves = [];
            const pieceType = piece.toLowerCase();
            const isWhite = piece === piece.toUpperCase();
            
            switch(pieceType) {
                case 'p': // Пешка
                    calculatePawnMoves(row, col, isWhite);
                    break;
                case 'n': // Конь
                    calculateKnightMoves(row, col, isWhite);
                    break;
                case 'b': // Слон
                    calculateSliderMoves(row, col, isWhite, DIRECTIONS.bishop);
                    break;
                case 'r': // Ладья
                    calculateSliderMoves(row, col, isWhite, DIRECTIONS.rook);
                    break;
                case 'q': // Ферзь
                    calculateSliderMoves(row, col, isWhite, DIRECTIONS.queen);
                    break;
                case 'k': // Король
                    calculateKingMoves(row, col, isWhite);
                    break;
            }
        }

        function calculatePawnMoves(row, col, isWhite) {
            const direction = isWhite ? -1 : 1;
            const startRow = isWhite ? 6 : 1;
            
            // Ход вперед на одну клетку
            let newRow = row + direction;
            if (newRow >= 0 && newRow < 8 && !gameState.board[newRow][col]) {
                gameState.legalMoves.push({ row: newRow, col, type: 'move' });
                
                // Двойной ход с начальной позиции
                if (row === startRow) {
                    newRow = row + 2 * direction;
                    if (!gameState.board[newRow][col]) {
                        gameState.legalMoves.push({ row: newRow, col, type: 'move' });
                    }
                }
            }
            
            // Взятия (ПРАВИЛЬНО!)
            const captures = [[direction, -1], [direction, 1]];
            for (const [dr, dc] of captures) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (targetPiece) {
                        // Вражеская фигура?
                        const isEnemy = (isWhite && targetPiece === targetPiece.toLowerCase()) ||
                                       (!isWhite && targetPiece === targetPiece.toUpperCase());
                        if (isEnemy) {
                            gameState.legalMoves.push({ row: newRow, col: newCol, type: 'capture' });
                        }
                    }
                }
            }
        }

        function calculateKnightMoves(row, col, isWhite) {
            for (const [dr, dc] of DIRECTIONS.knight) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (!targetPiece) {
                        gameState.legalMoves.push({ row: newRow, col: newCol, type: 'move' });
                    } else {
                        const isEnemy = (isWhite && targetPiece === targetPiece.toLowerCase()) ||
                                       (!isWhite && targetPiece === targetPiece.toUpperCase());
                        if (isEnemy) {
                            gameState.legalMoves.push({ row: newRow, col: newCol, type: 'capture' });
                        }
                    }
                }
            }
        }

        function calculateSliderMoves(row, col, isWhite, directions) {
            for (const [dr, dc] of directions) {
                let currentRow = row + dr;
                let currentCol = col + dc;
                
                while (currentRow >= 0 && currentRow < 8 && currentCol >= 0 && currentCol < 8) {
                    const targetPiece = gameState.board[currentRow][currentCol];
                    
                    if (!targetPiece) {
                        gameState.legalMoves.push({ row: currentRow, col: currentCol, type: 'move' });
                    } else {
                        const isEnemy = (isWhite && targetPiece === targetPiece.toLowerCase()) ||
                                       (!isWhite && targetPiece === targetPiece.toUpperCase());
                        if (isEnemy) {
                            gameState.legalMoves.push({ row: currentRow, col: currentCol, type: 'capture' });
                        }
                        break; // Прерываемся после встречи любой фигуры
                    }
                    
                    currentRow += dr;
                    currentCol += dc;
                }
            }
        }

        function calculateKingMoves(row, col, isWhite) {
            for (const [dr, dc] of DIRECTIONS.king) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if (!targetPiece) {
                        gameState.legalMoves.push({ row: newRow, col: newCol, type: 'move' });
                    } else {
                        const isEnemy = (isWhite && targetPiece === targetPiece.toLowerCase()) ||
                                       (!isWhite && targetPiece === targetPiece.toUpperCase());
                        if (isEnemy) {
                            gameState.legalMoves.push({ row: newRow, col: newCol, type: 'capture' });
                        }
                    }
                }
            }
        }

        function showLegalMoves() {
            for (const move of gameState.legalMoves) {
                let displayRow = move.row;
                let displayCol = move.col;
                
                if (gameState.playerColor === 'black') {
                    displayRow = 7 - move.row;
                    displayCol = 7 - move.col;
                }
                
                const square = document.querySelector(`.board-square[data-row="${displayRow}"][data-col="${displayCol}"]`);
                if (square) {
                    if (move.type === 'capture') {
                        square.classList.add('legal-capture');
                    } else {
                        square.classList.add('legal-move');
                    }
                }
            }
        }

        function clearSelection() {
            document.querySelectorAll('.board-square.selected').forEach(sq => sq.classList.remove('selected'));
            document.querySelectorAll('.board-square.legal-move, .board-square.legal-capture').forEach(sq => {
                sq.classList.remove('legal-move', 'legal-capture');
            });
            gameState.selectedSquare = null;
            gameState.legalMoves = [];
        }

        function isLegalMove(from, to) {
            // Проверяем, есть ли этот ход в списке разрешенных
            return gameState.legalMoves.some(move => 
                move.row === to.row && move.col === to.col
            );
        }

        // ==================== STOCKFISH ХОДЫ ====================
        function getEngineMove() {
            if (!gameState.isGameActive || gameState.currentTurn === gameState.playerColor) return;
            
            gameState.isAnalyzing = true;
            updateEngineStatus('thinking');
            showThinkingIndicator(true);
            
            if (gameState.stockfishReady) {
                const fen = getCurrentFEN();
                sendToStockfish(`position fen ${fen}`);
                sendToStockfish(`setoption name Skill Level value ${gameState.engineLevel}`);
                sendToStockfish('go depth 12 movetime 2000');
            } else {
                // Fallback на случайный движок
                setTimeout(() => {
                    makeRandomEngineMove();
                    gameState.isAnalyzing = false;
                    updateEngineStatus('ready');
                    showThinkingIndicator(false);
                }, 1000);
            }
        }

        function processEngineMove(moveUCI) {
            if (moveUCI.length < 4) return;
            
            const fromCol = moveUCI.charCodeAt(0) - 97;
            const fromRow = 8 - parseInt(moveUCI[1]);
            const toCol = moveUCI.charCodeAt(2) - 97;
            const toRow = 8 - parseInt(moveUCI[3]);
            let promotion = '';
            
            if (moveUCI.length === 5) {
                promotion = moveUCI[4];
            }
            
            const from = { row: fromRow, col: fromCol };
            const to = { row: toRow, col: toCol };
            
            // Сохраняем состояние для отмены
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            gameState.moveHistory.push({
                board: JSON.parse(JSON.stringify(gameState.board)),
                fen: gameState.positionFEN,
                moveCount: gameState.moves.length,
                capturedPiece: capturedPiece,
                from: from,
                to: to
            });
            
            // Выполняем ход
            if (promotion) {
                const isWhite = piece === piece.toUpperCase();
                gameState.board[toRow][toCol] = isWhite ? promotion.toUpperCase() : promotion;
            } else {
                gameState.board[toRow][toCol] = piece;
            }
            
            gameState.board[fromRow][fromCol] = null;
            
            // Меняем очередь хода
            gameState.currentTurn = 'white';
            
            // Сохраняем ход
            gameState.moves.push(moveUCI);
            
            // Если взяли фигуру, показываем уведомление
            if (capturedPiece) {
                const pieceNames = {
                    'p': 'пешку', 'n': 'коня', 'b': 'слона', 'r': 'ладью', 'q': 'ферзя', 'k': 'короля',
                    'P': 'пешку', 'N': 'коня', 'B': 'слона', 'R': 'ладью', 'Q': 'ферзя', 'K': 'короля'
                };
                const pieceName = pieceNames[capturedPiece] || 'фигуру';
                showNotification(`Stockfish взял вашу ${pieceName}!`, 'error');
            }
            
            // Обновляем FEN
            gameState.positionFEN = getCurrentFEN();
            calculateMaterialBalance();
            
            updateBoard();
            updateDisplay();
            showThinkingIndicator(false);
            
            // Включаем кнопку отмены
            document.getElementById('undo-btn').disabled = false;
            
            gameState.isAnalyzing = false;
            
            // Проверяем состояние игры
            checkGameState();
        }

        function makeRandomEngineMove() {
            // Находим фигуры движка
            const pieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const isEnginePiece = (gameState.playerColor === 'white' && piece === piece.toLowerCase()) ||
                                             (gameState.playerColor === 'black' && piece === piece.toUpperCase());
                        if (isEnginePiece) {
                            pieces.push({ piece, row, col });
                        }
                    }
                }
            }
            
            if (pieces.length === 0) return;
            
            // Пытаемся найти хороший ход (особенно взятие)
            let bestMove = null;
            let bestScore = -9999;
            
            for (const pieceData of pieces) {
                calculateLegalMoves(pieceData.row, pieceData.col, pieceData.piece);
                
                for (const move of gameState.legalMoves) {
                    let score = 0;
                    const targetPiece = gameState.board[move.row][move.col];
                    
                    // Оцениваем ход (взятие лучше!)
                    if (targetPiece) {
                        // Взятие - тем лучше, чем ценнее фигура
                        const pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 10000 };
                        const value = pieceValues[targetPiece.toLowerCase()] || 0;
                        score = value + 1000; // Бонус за взятие
                    } else {
                        // Простой ход
                        score = 10;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { from: { row: pieceData.row, col: pieceData.col }, to: move };
                    }
                }
                
                gameState.legalMoves = [];
            }
            
            if (bestMove) {
                const from = bestMove.from;
                const to = bestMove.to;
                makeMove(from, to);
            }
        }

        function analyzePosition() {
            if (!gameState.stockfishReady || gameState.isAnalyzing) {
                showNotification('Stockfish не готов или уже анализирует', 'warning');
                return;
            }
            
            gameState.isAnalyzing = true;
            updateEngineStatus('thinking');
            showThinkingIndicator(true);
            
            const fen = getCurrentFEN();
            sendToStockfish(`position fen ${fen}`);
            sendToStockfish(`setoption name Skill Level value ${gameState.engineLevel}`);
            sendToStockfish('go depth 15');
            
            setTimeout(() => {
                sendToStockfish('stop');
                gameState.isAnalyzing = false;
                updateEngineStatus('ready');
                showThinkingIndicator(false);
                showNotification('Анализ завершен', 'success');
            }, 3000);
        }

        // ==================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ====================
        function calculateMaterialBalance() {
            const pieceValues = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 0 };
            let balance = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const value = pieceValues[piece.toLowerCase()] || 0;
                        if (piece === piece.toUpperCase()) { // белая фигура
                            balance += value;
                        } else { // черная фигура
                            balance -= value;
                        }
                    }
                }
            }
            
            // Корректируем для игрока
            if (gameState.playerColor === 'black') {
                balance = -balance;
            }
            
            gameState.materialBalance = balance;
            return balance;
        }

        function checkGameState() {
            // Упрощенная проверка на мат (нет короля)
            let whiteKing = false;
            let blackKing = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if (piece === 'K') whiteKing = true;
                    if (piece === 'k') blackKing = true;
                }
            }
            
            if (!whiteKing) {
                gameState.isGameActive = false;
                showNotification('Мат! Черные выиграли.', 'error');
                return;
            }
            
            if (!blackKing) {
                gameState.isGameActive = false;
                showNotification('Мат! Белые выиграли.', 'success');
                return;
            }
        }

        function showHint() {
            if (!gameState.stockfishReady || gameState.currentTurn !== gameState.playerColor) {
                showNotification('Невозможно дать подсказку', 'warning');
                return;
            }
            
            gameState.isAnalyzing = true;
            updateEngineStatus('thinking');
            showThinkingIndicator(true);
            
            const fen = getCurrentFEN();
            sendToStockfish(`position fen ${fen}`);
            sendToStockfish(`setoption name Skill Level value ${gameState.engineLevel}`);
            sendToStockfish('go depth 10 movetime 1000');
            
            setTimeout(() => {
                sendToStockfish('stop');
                gameState.isAnalyzing = false;
                updateEngineStatus('ready');
                showThinkingIndicator(false);
                showNotification('Подсказка от Stockfish в консоли', 'info');
            }, 1000);
        }

        // ==================== ОБНОВЛЕНИЕ ИНТЕРФЕЙСА ====================
        function updateDisplay() {
            // Обновляем чей ход
            document.getElementById('current-turn').textContent = 
                gameState.currentTurn === 'white' ? 'белых' : 'черных';
            
            // Обновляем счетчик ходов
            document.getElementById('move-count').textContent = gameState.moves.length;
            
            // Обновляем уровень сложности
            document.getElementById('current-level').textContent = gameState.engineLevel;
            document.getElementById('engine-level-display').textContent = gameState.engineLevel;
            
            // Обновляем оценку позиции
            updateEvaluationDisplay();
            
            // Обновляем статус игры
            const statusElement = document.getElementById('game-status');
            if (gameState.isGameActive) {
                const isPlayerTurn = gameState.currentTurn === gameState.playerColor;
                statusElement.textContent = isPlayerTurn ? 'Ваш ход' : 'Ход Stockfish';
                statusElement.style.color = isPlayerTurn ? '#4cc9f0' : '#e94560';
            } else {
                statusElement.textContent = 'Игра завершена';
                statusElement.style.color = '#FF9800';
            }
            
            // Обновляем ELO игрока
            updatePlayerElo();
        }

        function updateEvaluationDisplay() {
            const evalElement = document.getElementById('position-eval');
            let displayEval = gameState.positionEvaluation;
            
            // Корректируем оценку для игрока
            if (gameState.playerColor === 'black') {
                displayEval = -displayEval;
            }
            
            // Форматируем отображение
            if (displayEval > 100) {
                evalElement.textContent = 'Мат ' + Math.round(displayEval / 100);
            } else if (displayEval < -100) {
                evalElement.textContent = 'Мат ' + Math.round(-displayEval / 100);
            } else {
                evalElement.textContent = (displayEval > 0 ? '+' : '') + displayEval.toFixed(2);
            }
            
            // Цвет оценки
            evalElement.classList.remove('positive-eval', 'negative-eval', 'zero-eval');
            if (displayEval > 0.5) {
                evalElement.classList.add('positive-eval');
            } else if (displayEval < -0.5) {
                evalElement.classList.add('negative-eval');
            } else {
                evalElement.classList.add('zero-eval');
            }
        }

        function updatePlayerElo() {
            const baseElo = 1200 + (gameState.engineLevel * 50);
            const moveCount = gameState.moves.length;
            const evalScore = Math.abs(gameState.positionEvaluation);
            
            let elo = baseElo;
            
            // Корректируем ELO на основе качества игры
            if (moveCount > 10) {
                if (evalScore < 1.0) {
                    elo += 100; // Хорошая игра
                } else if (evalScore > 3.0) {
                    elo -= 100; // Плохая позиция
                }
                
                // Учитываем длину партии
                if (moveCount > 30) elo += 50;
                if (moveCount > 50) elo += 30;
            }
            
            // Ограничиваем разумными пределами
            elo = Math.max(400, Math.min(2800, elo));
            document.getElementById('player-elo').textContent = Math.round(elo);
        }

        function showThinkingIndicator(show) {
            const indicator = document.getElementById('thinking-indicator');
            if (show) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        function showNotification(message, type = 'info') {
            const container = document.getElementById('notification-container');
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            
            // Иконка в зависимости от типа
            let icon = 'info-circle';
            switch(type) {
                case 'success': icon = 'check-circle'; break;
                case 'warning': icon = 'exclamation-triangle'; break;
                case 'error': icon = 'times-circle'; break;
            }
            
            notification.innerHTML = `
                <i class="fas fa-${icon}"></i>
                <span>${message}</span>
            `;
            
            container.appendChild(notification);
            
            // Автоматическое удаление через 5 секунд
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        // ==================== ОБРАБОТЧИКИ СОБЫТИЙ ====================
        function setupEventListeners() {
            // Новая игра
            document.getElementById('new-game-btn').addEventListener('click', startNewGame);
            
            // Отменить ход
            document.getElementById('undo-btn').addEventListener('click', undoMove);
            
            // Подсказка
            document.getElementById('hint-btn').addEventListener('click', showHint);
            
            // Анализ
            document.getElementById('analyze-btn').addEventListener('click', analyzePosition);
            
            // Выбор цвета
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const color = this.dataset.color;
                    
                    let selectedColor = color;
                    if (color === 'random') {
                        selectedColor = Math.random() > 0.5 ? 'white' : 'black';
                    }
                    
                    gameState.playerColor = selectedColor;
                    
                    // Обновляем активную кнопку
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    if (color !== 'random') {
                        this.classList.add('active');
                    } else {
                        document.getElementById(`color-${selectedColor}`).classList.add('active');
                    }
                    
                    showNotification(`Вы играете за ${selectedColor === 'white' ? 'белых' : 'черных'}`, 'info');
                    
                    // Перезапускаем игру с новым цветом
                    startNewGame();
                });
            });
            
            // Слайдер сложности
            const difficultySlider = document.getElementById('difficulty-slider');
            difficultySlider.addEventListener('input', function() {
                gameState.engineLevel = parseInt(this.value);
                document.getElementById('current-level').textContent = gameState.engineLevel;
                document.getElementById('engine-level-display').textContent = gameState.engineLevel;
                document.getElementById('difficulty-text').textContent = 
                    `Уровень ${gameState.engineLevel} (ELO ~${1200 + gameState.engineLevel * 50})`;
                
                if (gameState.stockfishReady) {
                    sendToStockfish(`setoption name Skill Level value ${gameState.engineLevel}`);
                }
            });
            
            // Обработка клавиш
            document.addEventListener('keydown', function(event) {
                switch(event.key) {
                    case 'n':
                    case 'N':
                        if (event.ctrlKey) startNewGame();
                        break;
                    case 'z':
                    case 'Z':
                        if (event.ctrlKey) undoMove();
                        break;
                    case 'h':
                    case 'H':
                        if (event.ctrlKey) showHint();
                        break;
                    case 'Escape':
                        clearSelection();
                        break;
                }
            });
        }
    </script>
</body>
</html>
